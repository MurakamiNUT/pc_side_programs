// Generated by gencpp from file pc_side_programs/Controller.msg
// DO NOT EDIT!


#ifndef PC_SIDE_PROGRAMS_MESSAGE_CONTROLLER_H
#define PC_SIDE_PROGRAMS_MESSAGE_CONTROLLER_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace pc_side_programs
{
template <class ContainerAllocator>
struct Controller_
{
  typedef Controller_<ContainerAllocator> Type;

  Controller_()
    : LS_Left_Right(0.0)
    , LS_Up_Down(0.0)
    , RS_Left_Right(0.0)
    , RS_Up_Down(0.0)
    , Left_Right(0.0)
    , Up_Down(0.0)
    , Triangle(false)
    , Circle(false)
    , Square(false)
    , Cross(false)
    , R1(false)
    , R2(false)
    , L1(false)
    , L2(false)
    , Select(false)
    , Start(false)
    , L3(false)
    , R3(false)
    , Left_wide(false)
    , L1s(false)
    , L2s(false)
    , Right_wide(false)
    , R1s(false)
    , R2s(false)
    , Left_17(false)
    , Left_19(false)
    , Left_20(false)
    , Right_22(false)
    , Right_23(false)
    , Right_24(false)  {
    }
  Controller_(const ContainerAllocator& _alloc)
    : LS_Left_Right(0.0)
    , LS_Up_Down(0.0)
    , RS_Left_Right(0.0)
    , RS_Up_Down(0.0)
    , Left_Right(0.0)
    , Up_Down(0.0)
    , Triangle(false)
    , Circle(false)
    , Square(false)
    , Cross(false)
    , R1(false)
    , R2(false)
    , L1(false)
    , L2(false)
    , Select(false)
    , Start(false)
    , L3(false)
    , R3(false)
    , Left_wide(false)
    , L1s(false)
    , L2s(false)
    , Right_wide(false)
    , R1s(false)
    , R2s(false)
    , Left_17(false)
    , Left_19(false)
    , Left_20(false)
    , Right_22(false)
    , Right_23(false)
    , Right_24(false)  {
  (void)_alloc;
    }



   typedef float _LS_Left_Right_type;
  _LS_Left_Right_type LS_Left_Right;

   typedef float _LS_Up_Down_type;
  _LS_Up_Down_type LS_Up_Down;

   typedef float _RS_Left_Right_type;
  _RS_Left_Right_type RS_Left_Right;

   typedef float _RS_Up_Down_type;
  _RS_Up_Down_type RS_Up_Down;

   typedef float _Left_Right_type;
  _Left_Right_type Left_Right;

   typedef float _Up_Down_type;
  _Up_Down_type Up_Down;

   typedef uint8_t _Triangle_type;
  _Triangle_type Triangle;

   typedef uint8_t _Circle_type;
  _Circle_type Circle;

   typedef uint8_t _Square_type;
  _Square_type Square;

   typedef uint8_t _Cross_type;
  _Cross_type Cross;

   typedef uint8_t _R1_type;
  _R1_type R1;

   typedef uint8_t _R2_type;
  _R2_type R2;

   typedef uint8_t _L1_type;
  _L1_type L1;

   typedef uint8_t _L2_type;
  _L2_type L2;

   typedef uint8_t _Select_type;
  _Select_type Select;

   typedef uint8_t _Start_type;
  _Start_type Start;

   typedef uint8_t _L3_type;
  _L3_type L3;

   typedef uint8_t _R3_type;
  _R3_type R3;

   typedef uint8_t _Left_wide_type;
  _Left_wide_type Left_wide;

   typedef uint8_t _L1s_type;
  _L1s_type L1s;

   typedef uint8_t _L2s_type;
  _L2s_type L2s;

   typedef uint8_t _Right_wide_type;
  _Right_wide_type Right_wide;

   typedef uint8_t _R1s_type;
  _R1s_type R1s;

   typedef uint8_t _R2s_type;
  _R2s_type R2s;

   typedef uint8_t _Left_17_type;
  _Left_17_type Left_17;

   typedef uint8_t _Left_19_type;
  _Left_19_type Left_19;

   typedef uint8_t _Left_20_type;
  _Left_20_type Left_20;

   typedef uint8_t _Right_22_type;
  _Right_22_type Right_22;

   typedef uint8_t _Right_23_type;
  _Right_23_type Right_23;

   typedef uint8_t _Right_24_type;
  _Right_24_type Right_24;





  typedef boost::shared_ptr< ::pc_side_programs::Controller_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::pc_side_programs::Controller_<ContainerAllocator> const> ConstPtr;

}; // struct Controller_

typedef ::pc_side_programs::Controller_<std::allocator<void> > Controller;

typedef boost::shared_ptr< ::pc_side_programs::Controller > ControllerPtr;
typedef boost::shared_ptr< ::pc_side_programs::Controller const> ControllerConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::pc_side_programs::Controller_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::pc_side_programs::Controller_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace pc_side_programs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'sensor_msgs': ['/opt/ros/kinetic/share/sensor_msgs/cmake/../msg'], 'pc_side_programs': ['/home/murakami/catkin_ws/src/pc_side_programs/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::pc_side_programs::Controller_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pc_side_programs::Controller_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pc_side_programs::Controller_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pc_side_programs::Controller_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pc_side_programs::Controller_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pc_side_programs::Controller_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::pc_side_programs::Controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "867de585fc3b5ab9ec116f9e91019d4d";
  }

  static const char* value(const ::pc_side_programs::Controller_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x867de585fc3b5ab9ULL;
  static const uint64_t static_value2 = 0xec116f9e91019d4dULL;
};

template<class ContainerAllocator>
struct DataType< ::pc_side_programs::Controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "pc_side_programs/Controller";
  }

  static const char* value(const ::pc_side_programs::Controller_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::pc_side_programs::Controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "  float32 LS_Left_Right\n\
  float32 LS_Up_Down\n\
  float32 RS_Left_Right\n\
  float32 RS_Up_Down\n\
  float32 Left_Right\n\
  float32 Up_Down\n\
\n\
  bool Triangle\n\
  bool Circle\n\
  bool Square\n\
  bool Cross\n\
  bool R1\n\
  bool R2\n\
  bool L1\n\
  bool L2\n\
  bool Select\n\
  bool Start\n\
  bool L3\n\
  bool R3\n\
\n\
  bool Left_wide\n\
  bool L1s\n\
  bool L2s\n\
  bool Right_wide\n\
  bool R1s\n\
  bool R2s\n\
  bool Left_17\n\
  bool Left_19\n\
  bool Left_20\n\
  bool Right_22\n\
  bool Right_23\n\
  bool Right_24\n\
";
  }

  static const char* value(const ::pc_side_programs::Controller_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::pc_side_programs::Controller_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.LS_Left_Right);
      stream.next(m.LS_Up_Down);
      stream.next(m.RS_Left_Right);
      stream.next(m.RS_Up_Down);
      stream.next(m.Left_Right);
      stream.next(m.Up_Down);
      stream.next(m.Triangle);
      stream.next(m.Circle);
      stream.next(m.Square);
      stream.next(m.Cross);
      stream.next(m.R1);
      stream.next(m.R2);
      stream.next(m.L1);
      stream.next(m.L2);
      stream.next(m.Select);
      stream.next(m.Start);
      stream.next(m.L3);
      stream.next(m.R3);
      stream.next(m.Left_wide);
      stream.next(m.L1s);
      stream.next(m.L2s);
      stream.next(m.Right_wide);
      stream.next(m.R1s);
      stream.next(m.R2s);
      stream.next(m.Left_17);
      stream.next(m.Left_19);
      stream.next(m.Left_20);
      stream.next(m.Right_22);
      stream.next(m.Right_23);
      stream.next(m.Right_24);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Controller_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::pc_side_programs::Controller_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::pc_side_programs::Controller_<ContainerAllocator>& v)
  {
    s << indent << "LS_Left_Right: ";
    Printer<float>::stream(s, indent + "  ", v.LS_Left_Right);
    s << indent << "LS_Up_Down: ";
    Printer<float>::stream(s, indent + "  ", v.LS_Up_Down);
    s << indent << "RS_Left_Right: ";
    Printer<float>::stream(s, indent + "  ", v.RS_Left_Right);
    s << indent << "RS_Up_Down: ";
    Printer<float>::stream(s, indent + "  ", v.RS_Up_Down);
    s << indent << "Left_Right: ";
    Printer<float>::stream(s, indent + "  ", v.Left_Right);
    s << indent << "Up_Down: ";
    Printer<float>::stream(s, indent + "  ", v.Up_Down);
    s << indent << "Triangle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Triangle);
    s << indent << "Circle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Circle);
    s << indent << "Square: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Square);
    s << indent << "Cross: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Cross);
    s << indent << "R1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.R1);
    s << indent << "R2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.R2);
    s << indent << "L1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L1);
    s << indent << "L2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L2);
    s << indent << "Select: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Select);
    s << indent << "Start: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Start);
    s << indent << "L3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L3);
    s << indent << "R3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.R3);
    s << indent << "Left_wide: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Left_wide);
    s << indent << "L1s: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L1s);
    s << indent << "L2s: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L2s);
    s << indent << "Right_wide: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Right_wide);
    s << indent << "R1s: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.R1s);
    s << indent << "R2s: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.R2s);
    s << indent << "Left_17: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Left_17);
    s << indent << "Left_19: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Left_19);
    s << indent << "Left_20: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Left_20);
    s << indent << "Right_22: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Right_22);
    s << indent << "Right_23: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Right_23);
    s << indent << "Right_24: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Right_24);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PC_SIDE_PROGRAMS_MESSAGE_CONTROLLER_H
